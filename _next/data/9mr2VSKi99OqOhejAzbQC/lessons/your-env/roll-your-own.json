{"pageProps":{"post":{"attributes":{"title":"Reinvent the wheel","description":"its one of the best past times"},"html":"<h2>Reinvent the wheel</h2>\n<p>I love reinventing the wheel.  There are many reasons why i like doing it too!</p>\n<br>\n<br>\n\n<h3>You will gain</h3>\n<ul>\n<li>a new appreciation of what it takes to create software</li>\n<li>learn a bunch about the topic along the way</li>\n<li>become a better engineer yourself, meaning you will now be able to guage\nproblems more accurately</li>\n</ul>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>My Current Bash Setup</h2>\n<p>This is obviously subject to change.  About once a year to every two years I\ntry to rethink through everything I have done and see if its something i like\nor hate.  That way I can continue to improve my system but I don&#39;t end up\nbecoming a meme of the continually pursuit of perfection.</p>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>Lets set some goals</h2>\n<ul>\n<li>I want to be able to bootstrap any machine i will purchase in the future that\nis ubuntu based.<ul>\n<li>i am not going to be clever and try to do a multiOS style, though this\nisn&#39;t hard its just tedious</li>\n<li>if i need a mac install script i am sure i can create a mac version</li>\n</ul>\n</li>\n<li>I want to be able to install all my favorite libraries</li>\n<li>I want the repos that i actively maintained brought down</li>\n<li>I want to be able to build neovim from source</li>\n<li>I want all the tools i use available</li>\n<li>I want to copy all my dotfiles over to my env.  i like them separated.</li>\n</ul>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>I just want it all</h2>\n<p>I really just want to automate my system with the greatest automation language\nof all time...</p>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<p>bash</p>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>Rolling out own</h2>\n<p>There are other versions of this exact same project that is someone elses\nversion.  I want to emphasize that I think the more you own of your system the\nbetter it will be because its exactly the way you want it.  You have the power\nto fashion it the way you want!</p>\n<br>\n<br>\n\n<p>But i am not foolish, this is also a double edge sword where you have to\nmaintain and improve your own system to make continue to make it great.</p>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>The idea</h2>\n<p>Create a script called <code>run</code> that will, based on some arguments passed in,\nwill run 0 or more scripts.  I want to make sure that scripts are easily\norganized so the scripts will be located in a subdirectory called <code>runs</code></p>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>My version</h2>\n<p>If you want to check out my final version of this product, check out my repo\nnamed <a href=\"https://github.com/theprimeagen/dev\">dev</a></p>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>Argument parsing and script setup</h2>\n<p>Now we need to write the ackshual run script.  Lets start with first creating\nthe dev environment.  Meaning getting the libraries, projects, editor, etc etc\nthat we want on our machine.</p>\n<p><em>Perhaps a bit of white boarding could be useful here...</em></p>\n<ul>\n<li>create a project directory anywhere you deem fit</li>\n<li>create a script called <code>run</code> within the directory you just created and make it executable (chmod +x run) within</li>\n<li>open up your favorite text editor neovim (maybe something else...)</li>\n</ul>\n<br>\n<br>\n\n<h3>Start simple</h3>\n<ul>\n<li>code up something that allows us to know the current directory and take in 1\nargument for filtering of tasks</li>\n</ul>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>Expected Code</h2>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/usr/bin/env bash</span>\n\nscript_dir=<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$( cd <span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$( dirname <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">${BASH_SOURCE[0]}</span>&quot;</span> )</span>&quot;</span> &amp;&gt; /dev/null &amp;&amp; pwd )</span>&quot;</span>\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$script_dir</span>&quot;</span>\n\nfilter=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$1</span>&quot;</span>\n\n<span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;Run: dir <span class=\"hljs-variable\">$script_dir</span> -- filter \\&quot;<span class=\"hljs-variable\">$filter</span>\\&quot;&quot;</span>\n</code></pre><br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>But how do we run scripts?</h2>\n<ul>\n<li><p>we need to use our current script location to figure out all the available\nscripts and run them one by one and if we have a mask/filter/grep then use\nthat to prevent any extra execution</p>\n</li>\n<li><p>coding time...</p>\n</li>\n</ul>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>Expected Code</h2>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-comment\"># ... previous section ...</span>\nscript_dir=<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(cd $(dirname <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">${BASH_SOURCE[0]}</span>&quot;</span>)</span> &amp;&amp; pwd)&quot;</span>\nfilter=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$1</span>&quot;</span>\n\n<span class=\"hljs-built_in\">cd</span> <span class=\"hljs-variable\">$script_dir</span>\nscripts=$(find runs -maxdepth 1 -mindepth 1 -executable -<span class=\"hljs-built_in\">type</span> f)\n\n<span class=\"hljs-keyword\">for</span> script <span class=\"hljs-keyword\">in</span> <span class=\"hljs-variable\">$scripts</span>; <span class=\"hljs-keyword\">do</span>\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$script</span>&quot;</span> | grep -qv <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$filter</span>&quot;</span>; <span class=\"hljs-keyword\">then</span>\n        <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;filtered: <span class=\"hljs-variable\">$filter</span> -- <span class=\"hljs-variable\">$script</span>&quot;</span>\n        <span class=\"hljs-built_in\">continue</span>\n    <span class=\"hljs-keyword\">fi</span>\n    ./<span class=\"hljs-variable\">$script</span>\n<span class=\"hljs-keyword\">done</span>\n</code></pre><br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>Quick Note</h2>\n<p>why single bracket comparison ?</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-keyword\">if</span> [ ! -z <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$myvar</span>&quot;</span> ]; <span class=\"hljs-keyword\">then</span> ...\n</code></pre><p>why double bracket comparison ?</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-keyword\">if</span> [[ <span class=\"hljs-variable\">$myvar</span> == <span class=\"hljs-string\">&quot;&quot;</span> ]]; <span class=\"hljs-keyword\">then</span> ...\n</code></pre><p>why no bracket comparison ?</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-variable\">$myvar</span> | grep -q <span class=\"hljs-string\">&quot;hello world&quot;</span>; <span class=\"hljs-keyword\">then</span> ...\n</code></pre><br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>Back to the program</h2>\n<p>We officially have our files being ran and we have filtering, and this is great.</p>\n<p>But what if we need to debug this bash script?  We don&#39;t really have a way\nother than add a bunch of print statements and potentially run some side\neffects we were not expecting</p>\n<p>We need a <code>dry_run</code>, so lets write it now!</p>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>Expected Code</h2>\n<p>Here is the full code up to this point</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-meta\">#!/usr/bin/env bash</span>\n\nscript_dir=<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">$(cd $(dirname <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">${BASH_SOURCE[0]}</span>&quot;</span>)</span> &amp;&amp; pwd)&quot;</span>\nfilter=<span class=\"hljs-string\">&quot;&quot;</span>\ndry=<span class=\"hljs-string\">&quot;0&quot;</span>\n\n<span class=\"hljs-built_in\">cd</span> <span class=\"hljs-variable\">$script_dir</span>\nscripts=$(find runs -maxdepth 1 -mindepth 1 -executable -<span class=\"hljs-built_in\">type</span> f)\n\n<span class=\"hljs-keyword\">while</span> [[ <span class=\"hljs-variable\">$#</span> &gt; 0 ]]; <span class=\"hljs-keyword\">do</span>\n    <span class=\"hljs-keyword\">if</span> [[ <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$1</span>&quot;</span> == <span class=\"hljs-string\">&quot;--dry&quot;</span> ]]; <span class=\"hljs-keyword\">then</span>\n        dry=<span class=\"hljs-string\">&quot;1&quot;</span>\n    <span class=\"hljs-keyword\">else</span>\n        filter=<span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$1</span>&quot;</span>\n    <span class=\"hljs-keyword\">fi</span>\n    <span class=\"hljs-built_in\">shift</span>\n<span class=\"hljs-keyword\">done</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-title\">log</span></span>() {\n    <span class=\"hljs-keyword\">if</span> [[ <span class=\"hljs-variable\">$dry</span> == <span class=\"hljs-string\">&quot;1&quot;</span> ]]; <span class=\"hljs-keyword\">then</span>\n        <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;[DRY_RUN]: <span class=\"hljs-variable\">$@</span>&quot;</span>\n    <span class=\"hljs-keyword\">else</span>\n        <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$@</span>&quot;</span>\n    <span class=\"hljs-keyword\">fi</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-title\">execute</span></span>() {\n    <span class=\"hljs-built_in\">log</span> <span class=\"hljs-string\">&quot;execute: <span class=\"hljs-variable\">$@</span>&quot;</span>\n    <span class=\"hljs-keyword\">if</span> [[ <span class=\"hljs-variable\">$dry</span> == <span class=\"hljs-string\">&quot;1&quot;</span> ]]; <span class=\"hljs-keyword\">then</span>\n        <span class=\"hljs-built_in\">return</span>\n    <span class=\"hljs-keyword\">fi</span>\n\n    <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$@</span>&quot;</span>\n}\n\n<span class=\"hljs-built_in\">log</span> <span class=\"hljs-string\">&quot;run: filter=<span class=\"hljs-variable\">$filter</span>&quot;</span>\n\n<span class=\"hljs-keyword\">for</span> script <span class=\"hljs-keyword\">in</span> <span class=\"hljs-variable\">$scripts</span>; <span class=\"hljs-keyword\">do</span>\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">echo</span> <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$script</span>&quot;</span> | grep -qv <span class=\"hljs-string\">&quot;<span class=\"hljs-variable\">$filter</span>&quot;</span>; <span class=\"hljs-keyword\">then</span>\n        <span class=\"hljs-built_in\">log</span> <span class=\"hljs-string\">&quot;filtered: <span class=\"hljs-variable\">$filter</span> -- <span class=\"hljs-variable\">$script</span>&quot;</span>\n        <span class=\"hljs-built_in\">continue</span>\n    <span class=\"hljs-keyword\">fi</span>\n    <span class=\"hljs-built_in\">log</span> <span class=\"hljs-string\">&quot;running script: <span class=\"hljs-variable\">$script</span>&quot;</span>\n    execute ./<span class=\"hljs-variable\">$script</span>\n<span class=\"hljs-keyword\">done</span>\n</code></pre><br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>Boom!</h2>\n<p>We now have a script that is easily extensible for setting up our environment</p>\n<ul>\n<li>You can add as many scripts as you would like</li>\n<li>You can filter which scripts get ran</li>\n<li>You can easily edit those scripts to be exactly what you want</li>\n</ul>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>Some cons</h2>\n<ul>\n<li>Bash sort of sucks..</li>\n<li>Keeping things up date is easy to forget<ul>\n<li>this is also why i always copy my environment.  i never edit the env files\ndirectly.  A good habit for me</li>\n</ul>\n</li>\n<li>Making it OS independent is a bit of a pain in the ass<ul>\n<li>i would argue its easier and up to as hard as ansible</li>\n</ul>\n</li>\n</ul>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n<h2>Other thoughts on dry runs</h2>\n<p>You <code>export DRY_RUN</code> during the dry run checks and then run every script and\nlet your scripts be the ones that tell you what it would be doing instead of\ndoing it.</p>\n<p>I just find that amount of logic is nice on paper but a huge pain in practice</p>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n","markdown":"\n## Reinvent the wheel\nI love reinventing the wheel.  There are many reasons why i like doing it too!\n\n<br>\n<br>\n\n### You will gain\n* a new appreciation of what it takes to create software\n* learn a bunch about the topic along the way\n* become a better engineer yourself, meaning you will now be able to guage\n  problems more accurately\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## My Current Bash Setup\nThis is obviously subject to change.  About once a year to every two years I\ntry to rethink through everything I have done and see if its something i like\nor hate.  That way I can continue to improve my system but I don't end up\nbecoming a meme of the continually pursuit of perfection.\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## Lets set some goals\n* I want to be able to bootstrap any machine i will purchase in the future that\n  is ubuntu based.\n  * i am not going to be clever and try to do a multiOS style, though this\n    isn't hard its just tedious\n  * if i need a mac install script i am sure i can create a mac version\n* I want to be able to install all my favorite libraries\n* I want the repos that i actively maintained brought down\n* I want to be able to build neovim from source\n* I want all the tools i use available\n* I want to copy all my dotfiles over to my env.  i like them separated.\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## I just want it all\nI really just want to automate my system with the greatest automation language\nof all time...\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\nbash\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## Rolling out own\nThere are other versions of this exact same project that is someone elses\nversion.  I want to emphasize that I think the more you own of your system the\nbetter it will be because its exactly the way you want it.  You have the power\nto fashion it the way you want!\n\n<br>\n<br>\n\nBut i am not foolish, this is also a double edge sword where you have to\nmaintain and improve your own system to make continue to make it great.\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## The idea\nCreate a script called `run` that will, based on some arguments passed in,\nwill run 0 or more scripts.  I want to make sure that scripts are easily\norganized so the scripts will be located in a subdirectory called `runs`\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## My version\nIf you want to check out my final version of this product, check out my repo\nnamed [dev](https://github.com/theprimeagen/dev)\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## Argument parsing and script setup\nNow we need to write the ackshual run script.  Lets start with first creating\nthe dev environment.  Meaning getting the libraries, projects, editor, etc etc\nthat we want on our machine.\n\n*Perhaps a bit of white boarding could be useful here...*\n\n* create a project directory anywhere you deem fit\n* create a script called `run` within the directory you just created and make it executable (chmod +x run) within\n* open up your favorite text editor neovim (maybe something else...)\n\n<br>\n<br>\n\n### Start simple\n* code up something that allows us to know the current directory and take in 1\nargument for filtering of tasks\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## Expected Code\n```bash\n#!/usr/bin/env bash\n\nscript_dir=\"$( cd \"$( dirname \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )\"\necho \"$script_dir\"\n\nfilter=\"$1\"\n\necho \"Run: dir $script_dir -- filter \\\"$filter\\\"\"\n```\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## But how do we run scripts?\n* we need to use our current script location to figure out all the available\n  scripts and run them one by one and if we have a mask/filter/grep then use\n  that to prevent any extra execution\n\n* coding time...\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## Expected Code\n\n```bash\n# ... previous section ...\nscript_dir=\"$(cd $(dirname \"${BASH_SOURCE[0]}\") && pwd)\"\nfilter=\"$1\"\n\ncd $script_dir\nscripts=$(find runs -maxdepth 1 -mindepth 1 -executable -type f)\n\nfor script in $scripts; do\n    if echo \"$script\" | grep -qv \"$filter\"; then\n        echo \"filtered: $filter -- $script\"\n        continue\n    fi\n    ./$script\ndone\n```\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## Quick Note\nwhy single bracket comparison ?\n\n```bash\nif [ ! -z \"$myvar\" ]; then ...\n```\nwhy double bracket comparison ?\n\n```bash\nif [[ $myvar == \"\" ]]; then ...\n```\n\nwhy no bracket comparison ?\n\n```bash\nif echo $myvar | grep -q \"hello world\"; then ...\n```\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## Back to the program\nWe officially have our files being ran and we have filtering, and this is great.\n\nBut what if we need to debug this bash script?  We don't really have a way\nother than add a bunch of print statements and potentially run some side\neffects we were not expecting\n\nWe need a `dry_run`, so lets write it now!\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## Expected Code\nHere is the full code up to this point\n\n```bash\n#!/usr/bin/env bash\n\nscript_dir=\"$(cd $(dirname \"${BASH_SOURCE[0]}\") && pwd)\"\nfilter=\"\"\ndry=\"0\"\n\ncd $script_dir\nscripts=$(find runs -maxdepth 1 -mindepth 1 -executable -type f)\n\nwhile [[ $# > 0 ]]; do\n    if [[ \"$1\" == \"--dry\" ]]; then\n        dry=\"1\"\n    else\n        filter=\"$1\"\n    fi\n    shift\ndone\n\nlog() {\n    if [[ $dry == \"1\" ]]; then\n        echo \"[DRY_RUN]: $@\"\n    else\n        echo \"$@\"\n    fi\n}\n\nexecute() {\n    log \"execute: $@\"\n    if [[ $dry == \"1\" ]]; then\n        return\n    fi\n\n    \"$@\"\n}\n\nlog \"run: filter=$filter\"\n\nfor script in $scripts; do\n    if echo \"$script\" | grep -qv \"$filter\"; then\n        log \"filtered: $filter -- $script\"\n        continue\n    fi\n    log \"running script: $script\"\n    execute ./$script\ndone\n```\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## Boom!\nWe now have a script that is easily extensible for setting up our environment\n\n* You can add as many scripts as you would like\n* You can filter which scripts get ran\n* You can easily edit those scripts to be exactly what you want\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## Some cons\n* Bash sort of sucks..\n* Keeping things up date is easy to forget\n  * this is also why i always copy my environment.  i never edit the env files\n  directly.  A good habit for me\n* Making it OS independent is a bit of a pain in the ass\n  * i would argue its easier and up to as hard as ansible\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n## Other thoughts on dry runs\nYou `export DRY_RUN` during the dry run checks and then run every script and\nlet your scripts be the ones that tell you what it would be doing instead of\ndoing it.\n\nI just find that amount of logic is nice on paper but a huge pain in practice\n\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n\n","slug":"roll-your-own","title":"Reinvent the wheel","section":"Your Env","icon":"info-circle","filePath":"/home/runner/work/dev-prod-2/dev-prod-2/lessons/02-your-env/C-roll-your-own.md","nextSlug":"/dev-prod-2/lessons/your-env/neovim","prevSlug":"/dev-prod-2/lessons/your-env/ansible"}},"__N_SSG":true}